package edu.cuanschutz.ccp.tm_provider.relation_extraction;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;

import java.io.IOException;
import java.util.HashSet;
import java.util.Set;

import org.junit.Test;

import edu.cuanschutz.ccp.tm_provider.etl.util.BiolinkConstants.BiolinkClass;
import edu.ucdenver.ccp.common.collections.CollectionsUtil;
import edu.ucdenver.ccp.common.file.CharacterEncoding;
import edu.ucdenver.ccp.common.io.ClassPathUtil;
import edu.ucdenver.ccp.file.conversion.TextDocument;
import edu.ucdenver.ccp.nlp.core.annotation.TextAnnotation;
import edu.ucdenver.ccp.nlp.core.annotation.TextAnnotationFactory;

public class ElasticsearchToBratExporterTest {
	private static final CharacterEncoding UTF8 = CharacterEncoding.UTF_8;

	@Test
	public void testBuildSentenceQuery() throws IOException {
		Set<Set<String>> ontologyPrefixes = new HashSet<Set<String>>();
		ontologyPrefixes.add(CollectionsUtil.createSet("DRUGBANK", "CHEBI"));
		ontologyPrefixes.add(CollectionsUtil.createSet("UBERON", "CL"));
		ontologyPrefixes.add(CollectionsUtil.createSet("GO"));
		String sentenceQuery = ElasticsearchToBratExporter.buildSentenceQuery(ontologyPrefixes);

		// @formatter:off
		String expectedSentenceQuery = "{\n" + 
				"	\"query\": {\n" + 
				"		\"bool\": {\n" + 
				"			\"must\": [\n" + 
				"				{\n" + 
				"					\"match\": {\n" + 
				"						\"annotatedText\": {\n" + 
				"							\"query\": \"CHEBI DRUGBANK\",\n" + 
				"							\"operator\": \"or\"\n" + 
				"						}\n" + 
				"					}\n" + 
				"				},\n" + 
				"				{\n" + 
				"					\"match\": {\n" + 
				"						\"annotatedText\": {\n" + 
				"							\"query\": \"CL UBERON\",\n" + 
				"							\"operator\": \"or\"\n" + 
				"						}\n" + 
				"					}\n" + 
				"				},\n" + 
				"				{\n" + 
				"					\"match\": {\n" + 
				"						\"annotatedText\": {\n" + 
				"							\"query\": \"GO\",\n" + 
				"							\"operator\": \"or\"\n" + 
				"						}\n" + 
				"					}\n" + 
				"				}\n" + 
				"			]\n" + 
				"		}\n" + 
				"	}\n" + 
				"}";
		// @formatter:on

		// the leading whitespace is different (indented in expectedSentenceQuery, but
		// not in the autogenerated version so we remove whitespace before making the
		// comparison.
		assertEquals(expectedSentenceQuery.replaceAll("\\s", ""), sentenceQuery.replaceAll("\\s", ""));
	}

	@Test
	public void testBuildAnnotatedTextMatchStanza() throws IOException {
		String annotatedTextMatchTemplate = ClassPathUtil.getContentsFromClasspathResource(
				ElasticsearchToBratExporter.class, ElasticsearchToBratExporter.ELASTIC_ANNOTATEDTEXT_MATCH_TEMPLATE,
				UTF8);
		String ontologyPrefixQueryString = "CHEBI DRUGBANK";
		String matchStanza = ElasticsearchToBratExporter.createAnnotatedTextMatchStanza(annotatedTextMatchTemplate,
				ontologyPrefixQueryString);

		// @formatter:off
		String expectedMatchStanza = "{\n" + 
				"	\"match\": {\n" + 
				"		\"annotatedText\": {\n" + 
				"			\"query\": \"CHEBI DRUGBANK\",\n" + 
				"			\"operator\": \"or\"\n" + 
				"		}\n" + 
				"	}\n" + 
				"}";
		// @formatter:on

		assertEquals(expectedMatchStanza, matchStanza);

	}

	@Test
	public void testExcludeBasedOnEntityIdsOnlySingleEntity() {

		Set<BiolinkClass> biolinkClasses = CollectionsUtil.createSet(BiolinkClass.CHEMICAL, BiolinkClass.DISEASE);
		TextAnnotationFactory factory = TextAnnotationFactory.createFactoryWithDefaults();
		TextDocument td = new TextDocument("PMID:12345", "PubMed", "Here is some text.");
		TextAnnotation annot1 = factory.createAnnotation(0, 10, "Hemoglobin", "DRUGBANK:DB04945");
		td.addAnnotation(annot1);

		TextDocument updatedTd = ElasticsearchToBratExporter.excludeBasedOnEntityIds(td,
				ElasticsearchToBratExporter.IDENTIFIERS_TO_EXCLUDE, biolinkClasses);

		assertNull(updatedTd);

	}

	@Test
	public void testExcludeBasedOnEntityIds() {

		Set<BiolinkClass> biolinkClasses = CollectionsUtil.createSet(BiolinkClass.CHEMICAL, BiolinkClass.DISEASE);
		TextAnnotationFactory factory = TextAnnotationFactory.createFactoryWithDefaults();
		TextDocument td = new TextDocument("PMID:12345", "PubMed", "Here is some text.");
		TextAnnotation annot1 = factory.createAnnotation(0, 10, "Hemoglobin", "DRUGBANK:DB04945");
		TextAnnotation annot2 = factory.createAnnotation(0, 10, "Hemoglobin", "MONDO:12345");
		td.addAnnotation(annot1);
		td.addAnnotation(annot2);

		TextDocument updatedTd = ElasticsearchToBratExporter.excludeBasedOnEntityIds(td,
				ElasticsearchToBratExporter.IDENTIFIERS_TO_EXCLUDE, biolinkClasses);

		Set<TextAnnotation> expectedAnnots = CollectionsUtil.createSet(annot1, annot2);

		assertNotNull(updatedTd);
		assertEquals(expectedAnnots, new HashSet<TextAnnotation>(updatedTd.getAnnotations()));

	}

	@Test
	public void testExcludeBasedOnEntityIdsFilterSomeOut() {

		Set<BiolinkClass> biolinkClasses = CollectionsUtil.createSet(BiolinkClass.CHEMICAL, BiolinkClass.DISEASE);
		TextAnnotationFactory factory = TextAnnotationFactory.createFactoryWithDefaults();
		TextDocument td = new TextDocument("PMID:12345", "PubMed", "Here is some text.");
		TextAnnotation annot1 = factory.createAnnotation(0, 10, "Hemoglobin", "DRUGBANK:DB04945");
		TextAnnotation annot2 = factory.createAnnotation(0, 10, "Hemoglobin", "MONDO:12345");
		TextAnnotation annot3 = factory.createAnnotation(0, 10, "Hemoglobin", "GO:12345");
		TextAnnotation annot4 = factory.createAnnotation(0, 10, "Hemoglobin", "CHEBI:12345");
		td.addAnnotation(annot1);
		td.addAnnotation(annot2);
		td.addAnnotation(annot3);
		td.addAnnotation(annot4);

		TextDocument updatedTd = ElasticsearchToBratExporter.excludeBasedOnEntityIds(td,
				ElasticsearchToBratExporter.IDENTIFIERS_TO_EXCLUDE, biolinkClasses);

		Set<TextAnnotation> expectedAnnots = CollectionsUtil.createSet(annot1, annot2, annot4);

		assertNotNull(updatedTd);
		assertEquals(expectedAnnots, new HashSet<TextAnnotation>(updatedTd.getAnnotations()));

	}

	@Test
	public void testDeserializeAnnotatedText() {

		Set<String> ontologyPrefixes = CollectionsUtil.createSet("DRUGBANK");
		String annotatedText = "(Hemoglobin)[DRUGBANK_DB04945&GO_0005833&_DRUGBANK&_GO] Q disorders including (hemoglobin)[DRUGBANK_DB04945&GO_0005833&_DRUGBANK&_GO] Q-Iran, (hemoglobin)[DRUGBANK_DB04945&GO_0005833&_DRUGBANK&_GO] Q-Thailand, and (hemoglobin)[DRUGBANK_DB04945&GO_0005833&_DRUGBANK&_GO] Q-India are important (hemoglobin)[DRUGBANK_DB04945&GO_0005833&_DRUGBANK&_GO] variants.";
		TextDocument td = ElasticsearchToBratExporter.deserializeAnnotatedText("PMID:1234", annotatedText,
				ontologyPrefixes);
		// 1 2 3 4 5 6 7 8 9 0 1 2 3
		// 012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
		String expectedText = "Hemoglobin Q disorders including hemoglobin Q-Iran, hemoglobin Q-Thailand, and hemoglobin Q-India are important hemoglobin variants.";
		assertEquals(expectedText, td.getText());

		Set<TextAnnotation> expectedAnnots = new HashSet<TextAnnotation>();
		TextAnnotationFactory factory = TextAnnotationFactory.createFactoryWithDefaults();
		expectedAnnots.add(factory.createAnnotation(0, 10, "Hemoglobin", "DRUGBANK:DB04945"));
//		expectedAnnots.add(factory.createAnnotation(0, 10, "Hemoglobin", "GO:0005833"));

		expectedAnnots.add(factory.createAnnotation(33, 43, "hemoglobin", "DRUGBANK:DB04945"));
//		expectedAnnots.add(factory.createAnnotation(33, 43, "hemoglobin", "GO:0005833"));

		expectedAnnots.add(factory.createAnnotation(52, 62, "hemoglobin", "DRUGBANK:DB04945"));
//		expectedAnnots.add(factory.createAnnotation(52, 62, "hemoglobin", "GO:0005833"));

		expectedAnnots.add(factory.createAnnotation(79, 89, "hemoglobin", "DRUGBANK:DB04945"));
//		expectedAnnots.add(factory.createAnnotation(79, 89, "hemoglobin", "GO:0005833"));

		expectedAnnots.add(factory.createAnnotation(112, 122, "hemoglobin", "DRUGBANK:DB04945"));
//		expectedAnnots.add(factory.createAnnotation(112, 122, "hemoglobin", "GO:0005833"));

		assertEquals(expectedAnnots, new HashSet<TextAnnotation>(td.getAnnotations()));

	}

}
